# 2-2 Create runner package

[Back to task list](./tasks.md)

## Description

Create a runner package (`internal/runner/runner.go`) that manages a module registry and executes modules in order with proper error handling and idempotency checks.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-27 00:00:00 | Created | N/A | Proposed | Task file created | sean |
| 2025-01-27 00:00:00 | Status Update | Proposed | InProgress | Started implementation | sean |
| 2025-01-27 00:00:00 | Status Update | InProgress | Review | Implementation complete, all tests passing | sean |
| 2025-01-27 00:00:00 | Status Update | Review | Done | Task approved and completed | sean |

## Requirements

1. Package located at `internal/runner/runner.go`
2. `Runner` struct with module registry (map[string]Module)
3. Methods:
   - `RegisterModule(module Module)` - Add module to registry
   - `RunModules(names []string, cfg *config.Config, dryRun bool) error` - Execute modules by name
4. Runner should:
   - Check `IsInstalled()` before running `Install()`
   - Skip modules that are already installed (log skip message)
   - Handle errors gracefully
   - Continue or stop based on error severity
   - Support dry-run mode
5. Use logging package for output

## Implementation Plan

1. Create `internal/runner/` directory
2. Create `runner.go` with package declaration
3. Import `internal/module`, `internal/config`, `internal/log`
4. Define `Runner` struct:
   - `modules map[string]Module`
   - `dryRun bool`
5. Implement `NewRunner()` constructor
6. Implement `RegisterModule()`:
   - Add module to map using `Name()` as key
   - Handle duplicate registration
7. Implement `RunModules()`:
   - Iterate through module names
   - Look up module in registry
   - If dry-run, log what would happen
   - Otherwise:
     - Check `IsInstalled()`
     - If installed, log skip and continue
     - If not installed, call `Install()`
     - Handle errors (log and return or continue based on severity)
8. Add error types for different failure modes
9. Add basic unit tests

## Verification

1. Modules can be registered
2. Runner executes modules in order
3. Runner skips already-installed modules
4. Runner handles errors correctly
5. Dry-run mode shows actions without executing
6. Unit tests pass

## Files Modified

- `internal/runner/runner.go` (new) - Implemented Runner struct with module registry, RegisterModule, RunModules, GetModule, and ListModules methods
- `internal/runner/runner_test.go` (new) - Comprehensive unit tests covering all functionality including error cases, dry-run mode, and idempotency
- `docs/api-specs/infrastructure/infrastructure-api.md` (updated) - Added Runner package API documentation

## Implementation Notes

### Implementation Details

1. **Runner package structure**:
   - Created `internal/runner/runner.go` with Runner struct and all required methods
   - Runner uses a `map[string]module.Module` for efficient module lookup
   - All methods follow Go best practices with proper error handling

2. **Key design decisions**:
   - `RegisterModule()` logs a warning if overwriting an existing module (allows flexibility)
   - `RunModules()` continues processing even if one module fails, collecting all errors
   - Dry-run mode checks `IsInstalled()` but never calls `Install()`
   - Idempotency is ensured by checking `IsInstalled()` before `Install()` in all cases
   - Helper methods `GetModule()` and `ListModules()` added for convenience

3. **Error handling**:
   - Empty module list returns an error immediately
   - Unknown modules are logged as errors and skipped (error collected)
   - `IsInstalled()` errors are logged and collected (module skipped)
   - `Install()` errors are logged and collected (execution continues)
   - All errors are returned together at the end if any occurred

4. **Testing approach**:
   - Created comprehensive unit tests with mock module implementation
   - Tests cover: registration, duplicate registration, empty list, unknown modules, success cases, skip installed, install errors, IsInstalled errors, dry-run mode, multiple modules, mixed scenarios
   - All tests use a mock module that implements the Module interface
   - Tests verify both success and error paths

### Code Quality

- ✅ `go fmt` - Code is properly formatted
- ✅ `go vet` - No static analysis issues
- ✅ All unit tests pass (17 test cases)
- ✅ Proper error handling (no panics)
- ✅ Follows Go best practices
- ✅ Comprehensive logging at appropriate levels

### Verification Results

1. ✅ Modules can be registered successfully
2. ✅ Runner executes modules in order
3. ✅ Runner skips already-installed modules (idempotency)
4. ✅ Runner handles errors correctly (continues processing, collects errors)
5. ✅ Dry-run mode shows actions without executing
6. ✅ All unit tests pass
7. ✅ Unknown modules are handled gracefully
8. ✅ Duplicate module registration is handled with warning

