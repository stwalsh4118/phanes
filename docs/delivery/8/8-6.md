# 8-6 Integrate runner with CLI execution

[Back to task list](./tasks.md)

## Description

Connect the runner package to the CLI for module execution. This includes creating a runner instance, registering modules, and executing the selected modules with proper error handling.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-27 00:00:00 | Created | N/A | Proposed | Task file created | sean |
| 2025-01-27 01:15:00 | Status Update | Proposed | InProgress | Started implementation | sean |
| 2025-01-27 01:20:00 | Status Update | InProgress | Review | Implementation complete, all tests passing | sean |
| 2025-01-27 07:50:00 | Status Update | Review | Done | Task approved and completed | sean |

## Requirements

1. Create runner instance using `runner.NewRunner()` or similar
2. Register all available modules with the runner
3. Determine which modules to execute:
   - If `--profile` is set, use modules from profile
   - If `--modules` is set, use parsed module list
   - If both are set, combine them (or handle appropriately)
4. Call `runner.RunModules()` with module names, config, and dry-run flag
5. Handle errors from runner execution
6. Log progress and results
7. Exit with appropriate code based on success/failure

## Implementation Plan

1. Create `executeModules(moduleNames []string, cfg *config.Config, dryRun bool) error` function in `main.go`
2. Create runner instance:
   - Import runner package
   - Create new runner (need to understand runner API)
3. Register modules:
   - Need to import all module packages
   - Register each module with runner
   - This might be done in a separate function or init
4. Execute modules:
   - Call `runner.RunModules(moduleNames, cfg, dryRun)`
   - Handle errors
5. Log execution start and completion
6. Call `executeModules()` from `runCommand()` after config and module selection
7. Handle the case where no modules are selected (show error or help)

## Verification

1. Runner is created successfully
2. Modules are registered correctly
3. Module execution works for valid modules
4. Errors from runner are handled and displayed
5. Execution progress is logged
6. Exit code reflects success/failure

## Test Plan

1. **Module execution**: Test with valid module list, verify execution
2. **Error handling**: Test with invalid module name, verify error
3. **Multiple modules**: Test with multiple modules, verify order
4. **Empty list**: Test with no modules, verify error or help
5. **Progress logging**: Verify execution progress is logged

## Files Modified

- `main.go` (updated) - Added `combineModules()` and `executeModules()` functions, integrated runner execution into `runCommand()`

## Implementation Notes

### Implementation Details

1. **Module Combination**:
   - Created `combineModules()` helper function that merges profile modules and selected modules
   - Profile modules are added first, followed by selected modules
   - Deduplicates module names to avoid executing the same module twice
   - Returns empty slice if both inputs are empty

2. **Module Execution**:
   - Created `executeModules()` function that:
     - Validates that at least one module is specified
     - Creates runner instance using `registerAllModules()` (reuses existing function)
     - Calls `runner.RunModules()` with module names, config, and dry-run flag
     - Handles errors from runner execution and wraps them with context
     - Logs execution start

3. **CLI Integration**:
   - Updated `runCommand()` to:
     - Combine profile modules and selected modules using `combineModules()`
     - Validate that at least one module is selected (returns error if empty)
     - Log the modules to be executed
     - Call `executeModules()` with combined modules, config, and dry-run flag
     - Log success message when all modules complete successfully
     - Return errors from execution (which are handled by Cobra and main())

4. **Error Handling**:
   - Empty module list: Returns error "no modules to execute"
   - Runner execution errors: Wrapped with context "module execution failed"
   - Runner handles module validation (unknown modules, installation failures)
   - Errors propagate through Cobra to main() which exits with code 1

### Code Quality

- ✅ `go build` - Code compiles successfully
- ✅ No linter errors
- ✅ Proper error handling with context
- ✅ Follows Go best practices
- ✅ Reuses existing `registerAllModules()` function
- ✅ All existing tests pass

### Verification Results

1. ✅ Runner is created successfully using `registerAllModules()`
2. ✅ Modules are registered correctly (baseline, user)
3. ✅ Module execution works for valid modules (via runner.RunModules)
4. ✅ Errors from runner are handled and displayed with context
5. ✅ Execution progress is logged ("Starting module execution...")
6. ✅ Exit code reflects success/failure (via Cobra error handling)
7. ✅ Profile modules and selected modules are combined correctly
8. ✅ Module deduplication works correctly
9. ✅ Empty module list is handled with error

